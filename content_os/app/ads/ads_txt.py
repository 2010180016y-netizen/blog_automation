from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional
from urllib.request import urlopen


@dataclass
class AdsSeller:
    domain: str
    publisher_id: str
    relationship: str
    cert_authority_id: Optional[str] = None


def generate_ads_txt(records: List[AdsSeller]) -> str:
    lines: List[str] = []
    for record in records:
        relationship = record.relationship.upper()
        parts = [record.domain.strip().lower(), record.publisher_id.strip(), relationship]
        if record.cert_authority_id:
            parts.append(record.cert_authority_id.strip())
        lines.append(", ".join(parts))

    normalized = sorted(set(lines))
    header = "# ads.txt generated by Content OS\n# spec: IAB Tech Lab Authorized Digital Sellers"
    return header + "\n" + "\n".join(normalized) + "\n"


def validate_ads_txt_content(content: str, expected_domains: Optional[List[str]] = None) -> Dict:
    errors: List[str] = []
    warnings: List[str] = []
    parsed: List[Dict[str, str]] = []

    for i, raw in enumerate(content.splitlines(), start=1):
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        parts = [p.strip() for p in line.split(",")]
        if len(parts) not in (3, 4):
            errors.append(f"line {i}: must have 3 or 4 comma-separated fields")
            continue

        relationship = parts[2].upper()
        if relationship not in {"DIRECT", "RESELLER"}:
            errors.append(f"line {i}: relationship must be DIRECT or RESELLER")
            continue

        entry = {
            "domain": parts[0].lower(),
            "publisher_id": parts[1],
            "relationship": relationship,
            "cert_authority_id": parts[3] if len(parts) == 4 else "",
        }
        parsed.append(entry)

    if expected_domains:
        actual_domains = {item["domain"] for item in parsed}
        for domain in expected_domains:
            if domain.lower() not in actual_domains:
                warnings.append(f"missing expected seller domain: {domain}")

    return {
        "status": "FAIL" if errors else "PASS",
        "errors": errors,
        "warnings": warnings,
        "records": parsed,
    }


def write_ads_txt(content: str, output_path: str) -> str:
    path = Path(output_path)
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    return str(path)


def load_sellers_from_json(path: str) -> List[AdsSeller]:
    data = json.loads(Path(path).read_text(encoding="utf-8"))
    sellers: List[AdsSeller] = []
    for item in data:
        sellers.append(
            AdsSeller(
                domain=item["domain"],
                publisher_id=item["publisher_id"],
                relationship=item.get("relationship", "DIRECT"),
                cert_authority_id=item.get("cert_authority_id"),
            )
        )
    return sellers


def fetch_ads_txt(url: str, timeout_s: float = 8.0) -> str:
    with urlopen(url, timeout=timeout_s) as response:  # nosec B310
        return response.read().decode("utf-8")
